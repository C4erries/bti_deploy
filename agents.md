# Инструкция для ИИ‑агентов по проекту «Умное БТИ»

Этот документ описывает, как ИИ‑агенты должны работать с проектом: что уже есть, что можно менять и какие приоритеты при доработке.

## 1. Общие принципы

- Соблюдай доменную модель и роли:
  - Клиент — создаёт и сопровождает заказы.
  - Исполнитель — работает с заказами, документами и выездами.
  - Администратор — управляет пользователями, справочниками, заказами и аналитикой.
- Сохраняй существующий технологический стек:
  - Backend: FastAPI, SQLAlchemy, Pydantic, SQLite (dev), JWT‑auth.
  - Frontend: React, Vite, Tailwind.
  - Docker: запуск через `docker-compose`, общий для `backend` и `frontend`.
- Работай итеративно:
  - сначала анализ (код, OpenAPI, схемы БД),
  - затем минимальные согласованные изменения,
  - потом проверка (запуск сервиса, быстрый ручной тест ключевых сценариев).

## 2. Структура репозитория (ориентировочно)

- `backend/`
  - `app/main.py` — создание FastAPI‑приложения, CORS, статика, подключение роутов.
  - `app/core/` — конфиг (`Settings`), безопасность (JWT, хэш паролей).
  - `app/db/` — engine, сессия, базовый класс моделей, типы (`GUID` и др.), сиды.
  - `app/models/` — SQLAlchemy‑модели: пользователи, профили, справочники, заказы, статусы, файлы, план‑версии, чат, назначения, календарь.
  - `app/schemas/` — Pydantic‑DTO (auth, user, directory, orders, plan, pricing, AI и др.).
  - `app/services/` — доменная логика (пользователи, заказы, справочники, исполнители, auth, калькулятор цены, чат).
  - `app/api/v1/` — роутер и эндпоинты:
    - `endpoints/auth.py`, `public.py`, `client_orders.py`, `client_chats.py`,
      `executor_orders.py`, `executor_calendar.py`, `admin_users.py`,
      `admin_orders.py`, `admin_directories.py`, `pricing.py` и др.
- `frontend/`
  - React + Vite + Tailwind UI:
    - API‑клиент (`src/api/client.ts`),
    - контекст авторизации,
    - разделы по ролям (auth, client, executor, admin),
    - компоненты для заказов, справочников, чата, визуализации планов (2D/3D) и т.д.
- `openapi.yaml`, `swagger.yaml`
  - OpenAPI‑спецификации текущего/целевого API (их допускается корректировать при изменении API).
- `problem.md`
  - Общее описание проблемы, целей проекта и целевого функционала (обновлено под актуальное ТЗ).

## 3. Работа с OpenAPI

- `openapi.yaml` и `swagger.yaml` — живой контракт, а не «священная корова».
- Допустимо:
  - исправлять ошибки в спецификации,
  - добавлять/обновлять схемы и пути при эволюции API,
  - убирать неиспользуемые/неактуальные части.
- Важно:
  - поддерживать согласованность между спецификациями, backend‑кодом и фронтендом,
  - если меняешь API (путь, схему, статус‑коды), обнови и спецификацию, и вызовы на фронте.

## 4. Backend‑агент: задачи и ограничения

### 4.1. Основные задачи

- Поддерживать и развивать REST‑API:
  - Auth: `/api/v1/auth/register/client`, `/api/v1/auth/login`, `/api/v1/auth/me`.
  - Публичные справочники: `/api/v1/services`, `/api/v1/districts`, `/api/v1/house-types`.
  - Публичный калькулятор: `/api/v1/calc/estimate` (использует `PriceCalculatorInput` и `PriceEstimateResponse`).
  - ЛК клиента:
    - `/api/v1/client/orders` и связанные эндпоинты (файлы, план, история статусов),
    - чат и AI‑анализ: `/api/v1/client/orders/{id}/ai/analyze`, `/api/v1/client/orders/{id}/ai/analysis`,
    - общий клиентский чат: `/api/v1/client/chats`, `/api/v1/chats/{chatId}/messages`,
    - AI‑эндпоинты сейчас заглушки, но схемы `AiAnalysis`, `AiRisk`, чат‑сообщений уже определены.
  - ЛК исполнителя:
    - `/api/v1/executor/orders`, `/api/v1/executor/orders/{id}`,
    - `/api/v1/executor/calendar`, планирование и изменение выездов.
  - Админка:
    - `/api/v1/admin/users`, `/api/v1/admin/executors`,
    - `/api/v1/admin/orders`,
    - `/api/v1/admin/services`, `/api/v1/admin/districts`, `/api/v1/admin/house-types`.
- Поддерживать доменную модель:
  - `User`, `ClientProfile`, `ExecutorProfile`,
  - `Department`, `Service`, `District`, `HouseType`,
  - `Order` и связанные сущности (`OrderStatusHistory`, `OrderFile`, `OrderPlanVersion`,
    `OrderChatMessage`, `ExecutorAssignment`, `ExecutorCalendarEvent` и др.).
- Расширения по новому ТЗ (ориентир):
  - Модуль AI‑ассистента:
    - анализ текстового описания и плана,
    - генерация 3–5 вариантов перепланировки и ремонта,
    - формирование `AiAnalysis` с рисками по типам (TECHNICAL, LEGAL, FINANCIAL, OPERATIONAL),
    - подсветка проблемных зон/стен через связь с `Plan` (roles, zones).
  - Модуль правил AI и журнал ошибок:
    - CRUD для правил (условие, тип риска, серьёзность, зона, статус, приоритет, теги),
    - журнал ошибок AI/бекенда/парсинга планов.
  - Парсинг планов и документов:
    - загрузка фото/сканов/файлов,
    - поэтапное развитие от заглушек к реальному извлечению геометрии в формат `Plan`.

### 4.2. Особенности реализации

- Все API‑пути должны оставаться под префиксом `/api/v1`.
- Валидация:
  - Pydantic‑схемы должны быть максимально близки к OpenAPI, но допускаются улучшения
    (переиспользование схем, alias‑ы в camelCase и т.п.).
- Домен по географии:
  - поле `address` остаётся,
  - поля `city` и `region` из доменной модели и API удалены — платформа привязана к одному городу/региону.
- План помещения и визуализация:
  - используется единый формат `Plan` (`backend/app/schemas/plan.py`) с элементами `wall/zone/door/window/label`;
  - статусы элементов (`EXISTING`, `TO_DELETE`, `NEW`, `MODIFIED`) используются и для визуализации, и для AI‑анализа;
  - 3D‑объекты (`PlanObject3D`) — вспомогательная надстройка над 2D‑планом; формат уже описан и используется фронтом.
- Калькулятор стоимости:
  - реализован сервис `calculate_price` и эндпоинт `/api/v1/calc/estimate`;
  - при развитии калькулятора под новое ТЗ расширяй `calculator_input` (виды работ, особенности, коэффициенты),
    не ломая существующий контракт.
- AI/визуализация:
  - в текущем MVP AI‑эндпоинты работают как заглушки, но:
    - схемы данных (`AiAnalysis`, `AiRisk`, `Plan`, `OrderPlanVersion`) должны быть корректными,
    - эндпоинты не должны падать и должны возвращать согласованные с фронтом структуры;
  - правила AI и журнал ошибок можно реализовывать как минимальные структуры, постепенно усложняя логику.

### 4.3. Что делать нельзя

- Менять стек (FastAPI → другой фреймворк и т.п.).
- Ломать существующие ключевые сценарии (login, создание заказа, получение списков)
  без синхронного обновления фронта и OpenAPI.
- Удалять существующие сущности и API без веской причины и миграционного плана.

## 5. Frontend‑агент: задачи и ограничения

### 5.1. Основные задачи

- Развивать UI поверх существующего API:
  - Авторизация и определение роли пользователя.
  - Для клиента:
    - каталог услуг и мастер создания заказа (выбор услуги, округа, типа дома),
    - загрузка файлов и планов, просмотр плана (JSON) и 2D/3D‑визуализации,
    - работа с версиями плана (`ORIGINAL` / `MODIFIED`),
    - просмотр истории статусов,
    - чат‑интерфейс с AI и исполнителем на базе существующих API,
    - панель калькулятора стоимости (связь с калькулятором на бэкенде).
  - Для исполнителя:
    - список заказов с фильтрами и сортировкой;
    - деталка заказа (информация, файлы, статусы, план);
    - действия «взять/отклонить», управление календарём выездов.
  - Для администратора:
    - управление пользователями (включая исполнителей);
    - модерация заказов;
    - управление справочниками;
    - базовый интерфейс для правил AI и журнала ошибок (структура + простые операции).
- Поддерживать связку с `VITE_API_URL`:
  - в dev Docker‑окружении использовать `http://localhost:8000/api/v1` как базовый URL,
  - все `path` в клиенте должны соответствовать путям без префикса (`/auth/...`, `/client/...` и т.д.),
    префикс добавляется через `API_URL`.

### 5.2. UX‑особенности

- При создании заказов:
  - не требовать от пользователя ввода города/региона;
  - предоставлять выбор округов, типов домов, услуг через списки, а не ввод кодов;
  - показывать ориентировочную стоимость и объяснять, что окончательное ценообразование за исполнителем.
- Визуализация плана и перепланировки:
  - показывать пользователю человекочитаемые значения (зоны, типы стен, статусы);
  - дать простой способ переключения между 2D (утверждение) и 3D (просмотр);
  - для будущего «конструктора ремонта» опираться на уже реализованный 3D‑просмотр и формат `Plan`.
- Обработка ошибок:
  - отображать ошибки API в понятном виде (статус + текст);
  - не «глотать» ошибки AI‑модулей, а показывать пользователю, что ответ носит предварительный характер.

### 5.3. Что делать нельзя

- Жёстко прошивать базовый URL API — всегда использовать `VITE_API_URL`/`API_URL`.
- Менять структуру ответов без согласования с backend‑частью и `openapi.yaml`.
- Вводить тяжёлые зависимости (UI‑библиотеки, state‑менеджеры и т.п.) без необходимости.

## 6. Согласованность backend ↔ frontend ↔ OpenAPI

- Любое изменение в API должно проходить через три шага:
  1. Обновление backend (модели, схемы, роуты).
  2. Обновление `openapi.yaml` (пути, схемы, статусы).
  3. Обновление вызовов на фронте (пути, DTO, обработка ошибок).
- Приоритет — рабочие пользовательские сценарии:
  - если приходится выбирать между «идеальной» схемой в OpenAPI и стабильной работой фронта/бека,
    предпочтительнее сначала сделать стабильность, потом аккуратно выровнять спецификацию.

## 7. Проверка и качество

- Backend‑агент:
  - по возможности прогоняй `python -m compileall backend/app`;
  - при изменениях, влияющих на API, минимально проверяй вызовы через HTTP‑клиент
    (curl, httpie, браузер).
- Frontend‑агент:
  - проверяй базовые сценарии руками в браузере:
    - регистрация/логин,
    - создание заказа,
    - просмотр списков и деталей,
    - переходы между ролями.
- Важно:
  - фиксировать ключевые допущения в комментариях или markdown‑файлах (например, в `problem.md`);
  - не оставлять «магические»/неочевидные решения без пояснения.


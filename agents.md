# Инструкция для ИИ‑агентов по проекту «Умное БТИ»

Этот документ описывает, как ИИ‑агенты должны работать с проектом: что уже есть, что можно менять и какие приоритеты при доработке.

## 1. Общие принципы

- Соблюдай доменную модель и роли:
  - Клиент — создаёт и сопровождает заказы.
  - Исполнитель — работает с заказами, документами и выездами.
  - Администратор — управляет пользователями, справочниками, заказами и аналитикой.
- Сохраняй существующий технологический стек:
  - Backend: FastAPI, SQLAlchemy, Pydantic, SQLite (dev), JWT‑auth.
  - Frontend: React, Vite, Tailwind.
  - Docker: запуск через `docker-compose`, общий для `backend` и `frontend`.
- Работай итеративно:
  - сначала анализ (код, OpenAPI, схемы БД),
  - затем минимальные согласованные изменения,
  - потом проверка (запуск сервиса, быстрый ручной тест ключевых сценариев).

## 2. Структура репозитория (ориентировочно)

- `backend/`
  - `app/main.py` — создание FastAPI‑приложения, CORS, статика, подключение роутов.
  - `app/core/` — конфиг (`Settings`), безопасность (JWT, хэш паролей).
  - `app/db/` — engine, сессия, базовый класс моделей, типы (`GUID` и др.), сиды.
  - `app/models/` — SQLAlchemy‑модели: пользователи, профили, справочники, заказы, статусы, файлы, план‑версии, чат, назначения, календарь.
  - `app/schemas/` — Pydantic‑DTO (auth, user, directory, orders, AI и др.).
  - `app/services/` — доменная логика (пользователи, заказы, справочники, исполнители, auth).
  - `app/api/v1/` — роутер и эндпоинты:
    - `endpoints/auth.py`, `public.py`, `client_orders.py`, `executor_orders.py`,
      `executor_calendar.py`, `admin_users.py`, `admin_orders.py`, `admin_directories.py` и др.
- `frontend/`
  - React + Vite + Tailwind UI:
    - API‑клиент (`src/api/client.ts`),
    - контекст авторизации,
    - разделы по ролям (auth, client, executor, admin),
    - компоненты для заказов, справочников, чата и т.д.
- `openapi.yaml`
  - OpenAPI‑спецификация текущего/целевого API (её допускается корректировать при изменении API).
- `problem.md`
  - Общее описание проблемы и целей проекта.

## 3. Работа с OpenAPI

- `openapi.yaml` — живой контракт, а не «священная корова».
- Допустимо:
  - исправлять ошибки в спецификации,
  - добавлять/обновлять схемы и пути при эволюции API,
  - убирать неиспользуемые/неактуальные части.
- Важно:
  - поддерживать согласованность между `openapi.yaml`, backend‑кодом и фронтендом,
  - если меняешь API (путь, схему, статус‑коды), обнови и спецификацию, и вызовы на фронте.

## 4. Backend‑агент: задачи и ограничения

### 4.1. Основные задачи

- Поддерживать и развивать REST‑API:
  - Auth: `/api/v1/auth/register/client`, `/api/v1/auth/login`, `/api/v1/auth/me`.
  - Публичные справочники: `/api/v1/services`, `/api/v1/districts`, `/api/v1/house-types`.
  - ЛК клиента: `/api/v1/client/orders` и связанные endpoints (файлы, план, история статусов, AI‑чат и анализ как заглушки).
  - ЛК исполнителя: `/api/v1/executor/orders`, `/api/v1/executor/orders/{id}`, `/api/v1/executor/calendar`, schedule‑visit и т.д.
  - Админка: `/api/v1/admin/users`, `/api/v1/admin/executors`, `/api/v1/admin/orders`, `/api/v1/admin/services`, `/api/v1/admin/districts`, `/api/v1/admin/house-types`.
- Поддерживать доменную модель:
  - `User`, `ClientProfile`, `ExecutorProfile`,
  - `Department`, `Service`, `District`, `HouseType`,
  - `Order` и связанные сущности (`OrderStatusHistory`, `OrderFile`, `OrderPlanVersion`, `OrderChatMessage`,
    `ExecutorAssignment`, `ExecutorCalendarEvent` и др.).
- Следить за тем, чтобы:
  - создаваемые/обновляемые объекты соответствовали бизнес‑логике (например, нельзя редактировать заказ в неподходящем статусе),
  - связи и внешние ключи были корректны.

### 4.2. Особенности реализации

- Все API‑пути должны оставаться под префиксом `/api/v1`.
- Валидация:
  - Pydantic‑схемы должны быть максимально близки к OpenAPI, но допускаются улучшения (переиспользование схем, alias‑ы camelCase и т.п.).
- Домен по географии:
  - поле `address` остаётся,
  - поля `city` и `region` из доменной модели и API удалены — платформа привязана к одному городу/региону.
- AI/визуализация:
  - в текущем MVP AI‑эндпоинты работают как заглушки, но:
    - схемы данных (планы, риски, summary и т.д.) должны быть корректными,
    - эндпоинты не должны падать;
  - правила AI и журнал ошибок можно реализовать как минимальные структуры на будущее.

### 4.3. Что делать нельзя

- Менять стек (FastAPI → другой фреймворк и т.п.).
- Ломать существующие ключевые сценарии (login, создание заказа, получение списков) без синхронного обновления фронта и OpenAPI.
- Удалять существующие сущности и API без веской причины и миграционного плана.

## 5. Frontend‑агент: задачи и ограничения

### 5.1. Основные задачи

- Развивать UI поверх существующего API:
  - Авторизация и определение роли пользователя.
  - Для клиента:
    - каталог услуг, мастер создания заказа (с выбором услуг, округов, типов домов из справочников),
    - загрузка файлов, просмотр плана и истории статусов,
    - чат‑интерфейс для общения с AI/исполнителем на базе доступных API.
  - Для исполнителя:
    - список заказов с фильтрами,
    - деталка заказа (информация, файлы, статусы),
    - действия «взять/отклонить», календарь выездов.
  - Для администратора:
    - управление пользователями (включая исполнителей),
    - модерация заказов,
    - управление справочниками,
    - базовый интерфейс для правил AI и журнала ошибок (структура без сложной логики).
- Поддерживать связку с `VITE_API_URL`:
  - в dev Docker‑окружении использовать `http://localhost:8000/api/v1` как базовый URL,
  - все `path` в клиенте должны соответствовать путям без префикса (`/auth/...`, `/client/...` и т.д.), префикс добавляется через `API_URL`.

### 5.2. UX‑особенности

- При создании заказов:
  - не требовать от пользователя ввода города/региона,
  - предоставлять выбор округов, типов домов, услуг через списки, а не ввод кодов.
- Показывать пользователю человекочитаемые значения (названия, статусы, названия отделов), а не внутренние коды.
- Обрабатывать ошибки API и отображать их в понятном виде (например, статус/текст).

### 5.3. Что делать нельзя

- Жёстко прошивать базовый URL API — всегда использовать `VITE_API_URL`/`API_URL`.
- Менять структуру ответов без согласования с backend‑частью и `openapi.yaml`.
- Вводить тяжёлые зависимости (UI‑библиотеки, state‑менеджеры и т.п.) без необходимости.

## 6. Согласованность backend ↔ frontend ↔ OpenAPI

- Любое изменение в API должно проходить через три шага:
  1. Обновление backend (модели, схемы, роуты).
  2. Обновление `openapi.yaml` (пути, схемы, статусы).
  3. Обновление вызовов на фронте (пути, DTO, обработка ошибок).
- Приоритет — рабочие пользовательские сценарии:
  - если приходится выбирать между «идеальной» схемой в OpenAPI и стабильной работой фронта/бека, предпочтительнее сначала сделать стабильность, потом аккуратно выровнять спецификацию.

## 7. Проверка и качество

- Backend‑агент:
  - по возможности прогоняй `python -m compileall backend/app`,
  - при изменениях, влияющих на API, минимально проверяй вызовы через HTTP‑клиент (curl, httpie, браузер).
- Frontend‑агент:
  - проверяй базовые сценарии руками в браузере:
    - регистрация/логин,
    - создание заказа,
    - просмотр списков и деталей,
    - переходы между ролями.
- Важно:
  - фиксировать ключевые допущения в комментариях или markdown‑файлах,
  - не оставлять «магические»/неочевидные решения без пояснения.

